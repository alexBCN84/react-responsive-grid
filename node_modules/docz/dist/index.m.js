import equal from 'fast-deep-equal';
import observe from 'callbag-observe';
import makeSubject from 'callbag-subject';
import { withRouter } from 'react-router';
import db from '~db';
import { NavHashLink } from 'react-router-hash-link';
import { ulid } from 'ulid';
import sort from 'array-sort';
import capitalize from 'capitalize';
import merge from 'deepmerge';
import { HashRouter, BrowserRouter, Switch, Route } from 'react-router-dom';
import { MDXProvider } from '@mdx-js/tag';
import { get, unionBy, pipe, omit } from 'lodash/fp';
import { withMDXComponents } from '@mdx-js/tag/dist/mdx-provider';
import importedComponent from 'react-imported-component';
import { Fragment, Component, createContext, createElement } from 'react';

function create(initial = {}) {
    var _a;
    const subject = makeSubject();
    const { Provider, Consumer } = createContext(initial);
    Consumer.displayName = 'StateConsumer';
    return {
        get: fn => createElement(Consumer, null, fn),
        set: fn => subject(1, fn),
        Provider: (_a = class CustomProvider extends Component {
                constructor() {
                    super(...arguments);
                    this.state = this.props.initial || initial;
                }
                componentDidMount() {
                    observe((v) => this.setState(v))(subject);
                }
                componentWillUnmount() {
                    subject(2);
                }
                shouldComponentUpdate(nextProps, nextState) {
                    return !equal(this.state, nextState);
                }
                render() {
                    return createElement(Provider, { value: this.state }, this.props.children);
                }
            },
            _a.displayName = 'StateProvider',
            _a),
    };
}

const state = create();

const styles = {
    wrapper: {
        overflowY: 'auto',
        padding: 50,
        display: 'flex',
        flexDirection: 'column',
        alignItems: 'center',
        width: '100vw',
        height: '100vh',
        background: 'white',
        fontFamily: 'monospace',
        fontSize: '14px',
    },
    page: {
        maxWidth: 960,
    },
    title: {
        margin: '0 0 30px',
    },
    subtitle: {
        margin: '30px 0 10px',
    },
    stack: {
        display: 'flex',
        flexDirection: 'column',
        marginBottom: '1em',
        marginTop: '1em',
    },
};
const ErrorReporter = ({ error, componentStack }) => (createElement("div", { style: styles.wrapper },
    createElement("div", { style: styles.page },
        createElement("h1", { style: styles.title }, "\uD83D\uDEA8 Whoops, we crashed \uD83D\uDEA8"),
        error && createElement("div", null, error.message),
        createElement("h2", { style: styles.subtitle }, "Stack trace"),
        componentStack && (createElement("div", { style: styles.stack }, componentStack.split('\n').map(str => (createElement("div", { key: str }, str))))))));
class ErrorBoundary extends Component {
    constructor() {
        super(...arguments);
        this.state = {
            error: null,
            componentStack: null,
        };
    }
    componentDidCatch(error, info) {
        this.setState({ error, componentStack: info ? info.componentStack : null });
    }
    render() {
        const { children } = this.props;
        const { error } = this.state;
        return error !== null ? createElement(ErrorReporter, Object.assign({}, this.state)) : children;
    }
}

class DataServer extends Component {
    constructor(props, ctx) {
        const { websocketUrl } = props;
        super(props, ctx);
        this.socket = websocketUrl ? new WebSocket(websocketUrl) : null;
    }
    componentDidMount() {
        if (this.socket)
            this.setupWebsockets(this.socket);
    }
    render() {
        return this.props.children;
    }
    setupWebsockets(socket) {
        socket.onmessage = (ev) => {
            const message = JSON.parse(ev.data);
            if (message.type === 'state.entries') {
                state.set(state$$1 => (Object.assign({}, state$$1, { entries: message.payload })));
            }
            if (message.type === 'state.config') {
                state.set(state$$1 => (Object.assign({}, state$$1, { config: message.payload })));
            }
        };
    }
}

class ScrollToTopBase extends Component {
    componentDidUpdate(prevProps) {
        if (this.props.location !== prevProps.location) {
            window.scrollTo(0, 0);
        }
    }
    render() {
        return this.props.children;
    }
}
const ScrollToTop = withRouter(ScrollToTopBase);

const Router = (props) => Boolean(DOCZ_HASH_ROUTER) ? (createElement(HashRouter, Object.assign({}, props))) : (createElement(BrowserRouter, Object.assign({}, props)));
function theme(themeConfig, transform = c => c) {
    return WrappedComponent => {
        const Theme = props => {
            const { wrapper: Wrapper } = props;
            const wrapped = Wrapper ? (createElement(Wrapper, null,
                createElement(WrappedComponent, null))) : (createElement(WrappedComponent, null));
            return (createElement(ErrorBoundary, null,
                createElement(state.Provider, { initial: Object.assign({}, db, { themeConfig, transform }) },
                    createElement(DataServer, { websocketUrl: DOCZ_WEBSOCKET_URL },
                        createElement(Router, { basename: DOCZ_BASE_URL },
                            createElement(ScrollToTop, null, wrapped))))));
        };
        return Theme;
    };
}

const isFn = (value) => typeof value === 'function';
function flatArrFromObject(arr, prop) {
    const reducer = (arr, obj) => {
        const value = get(prop)(obj);
        return value ? arr.concat([value]) : arr;
    };
    return Array.from(new Set(arr.reduce(reducer, [])));
}
function compare(a, b, reverse) {
    if (a < b)
        return reverse ? 1 : -1;
    if (a > b)
        return reverse ? -1 : 1;
    return 0;
}
function mergeArrBy(prop, a, b) {
    return unionBy(prop, a)(b);
}

const Docs = ({ children }) => {
    if (typeof children !== 'function')
        return null;
    return (createElement(Fragment, null, state.get(({ entries, config }) => {
        if (!entries || !config || !children)
            return null;
        if (!isFn(children)) {
            throw new Error('You need to pass a children as a function to your <Docs/> component');
        }
        const arr = Object.values(entries);
        /** TODO: remove all order and  logic from here in a breaking change */
        const menusArr = flatArrFromObject(arr, 'menu');
        const menus = sort(menusArr, (a, b) => compare(a, b));
        const descending = config.ordering === 'descending';
        const docs = sort(arr, (a, b) => compare(a.order, b.order, descending), (a, b) => compare(a.name, b.name));
        return children({
            menus,
            docs,
        });
    })));
};

const Link = props => createElement(NavHashLink, Object.assign({}, props, { exact: true }));

const noMenu = (entry) => !entry.menu;
const fromMenu = (menu) => (entry) => entry.menu === menu;
const entryAsMenu = (entry) => ({
    name: entry.name,
    route: entry.route,
    order: entry.order || 0,
});
const entriesOfMenu = (menu, entries) => entries.filter(fromMenu(menu)).map(entryAsMenu);
const parseMenu = (entries) => (name) => ({
    name,
    menu: entriesOfMenu(name, entries),
});
const menusFromEntries = (entries) => {
    const entriesWithoutMenu = entries.filter(noMenu).map(entryAsMenu);
    const menus = flatArrFromObject(entries, 'menu').map(parseMenu(entries));
    return [...entriesWithoutMenu, ...menus];
};
const parseItemStr = (item) => typeof item === 'string' ? { name: item } : item;
const normalize = (item) => {
    const selected = parseItemStr(item);
    return Object.assign({}, selected, { id: selected.id || ulid(), order: selected.order || 0, menu: Array.isArray(selected.menu)
            ? selected.menu.map(normalize)
            : selected.menu });
};
const clean = (item) => item.href || item.route ? omit('menu', item) : item;
const normalizeAndClean = pipe(normalize, clean);
const mergeMenus = (entriesMenu, configMenu) => {
    const first = entriesMenu.map(normalizeAndClean);
    const second = configMenu.map(normalizeAndClean);
    const merged = mergeArrBy('name', first, second);
    return merged.map(item => {
        if (!item.menu)
            return item;
        const found = second.find(i => i.name === item.name);
        const foundMenu = found && found.menu;
        return Object.assign({}, item, { menu: foundMenu
                ? mergeMenus(item.menu, foundMenu)
                : item.menu || found.menu });
    });
};
const UNKNOWN_POS = Infinity;
const findPos = (item, orderedList = []) => {
    const name = typeof item !== 'string' ? get('name', item) : item;
    const pos = orderedList.findIndex(item => item === name);
    return pos !== -1 ? pos : UNKNOWN_POS;
};
const compareWithMenu = (to = []) => (a, b) => {
    const list = to.map((i) => i.name || i);
    return compare(findPos(a, list), findPos(b, list));
};
const sortMenus = (first, second = [], reverse) => {
    const sorted = sort(first, compareWithMenu(second), (a, b) => compare(a.order, b.order, reverse));
    return sorted.map(item => {
        if (!item.menu)
            return item;
        const found = second.find(menu => menu.name === item.name);
        const foundMenu = found && found.menu;
        return Object.assign({}, item, { menu: foundMenu ? sortMenus(item.menu, foundMenu, reverse) : item.menu });
    });
};
const Menu = ({ children }) => {
    if (typeof children !== 'function')
        return null;
    return (createElement(Fragment, null, state.get(({ entries, config }) => {
        if (!entries || !config || !children)
            return null;
        if (!isFn(children)) {
            throw new Error('You need to pass a children as a function to your <Docs/> component');
        }
        const reverse = config.ordering === 'descending';
        const arr = Object.values(entries);
        const entriesMenu = menusFromEntries(arr);
        const merged = mergeMenus(entriesMenu, config.menu);
        const menus = sortMenus(merged, config.menu, reverse);
        return children(menus);
    })));
};

const BasePlayground = ({ components, className, style, wrapper: Wrapper, children, __scope, __position, __code, __codesandbox, }) => {
    if (!components || !components.render)
        return null;
    const props = { className, style, components };
    return (createElement(components.render, Object.assign({}, props, { component: Wrapper ? createElement(Wrapper, null, children) : children, scope: __scope, position: __position, code: __code, codesandbox: __codesandbox })));
};
const Playground = withMDXComponents(BasePlayground);

const RE_OBJECTOF = /(?:React\.)?(?:PropTypes\.)?objectOf\((?:React\.)?(?:PropTypes\.)?(\w+)\)/;
const getTypeStr = (type) => {
    switch (type.name.toLowerCase()) {
        case 'instanceof':
            return `Class(${type.value})`;
        case 'enum':
            if (type.computed)
                return type.value;
            return type.value
                ? type.value.map((v) => `${v.value}`).join(' │ ')
                : type.raw;
        case 'union':
            return type.value
                ? type.value.map((t) => `${getTypeStr(t)}`).join(' │ ')
                : type.raw;
        case 'array':
            return type.raw;
        case 'arrayof':
            return `Array<${getTypeStr(type.value)}>`;
        case 'custom':
            if (type.raw.indexOf('function') !== -1 || type.raw.indexOf('=>') !== -1)
                return 'Custom(Function)';
            else if (type.raw.toLowerCase().indexOf('objectof') !== -1) {
                const m = type.raw.match(RE_OBJECTOF);
                if (m && m[1])
                    return `ObjectOf(${capitalize(m[1])})`;
                return 'ObjectOf';
            }
            return 'Custom';
        case 'bool':
            return 'Boolean';
        case 'func':
            return 'Function';
        case 'shape':
            const shape = type.value;
            const rst = {};
            Object.keys(shape).forEach(key => {
                rst[key] = getTypeStr(shape[key]);
            });
            return JSON.stringify(rst, null, 2);
        default:
            return capitalize(type.name);
    }
};
const humanize = (type) => getTypeStr(type);

const styles$1 = {
    thead: {
        textAlign: 'left',
    },
};
const getPropType = (prop, Tooltip) => {
    const propName = prop.flowType ? prop.flowType.name : prop.type.name;
    const isEnum = propName.startsWith('"') || propName === 'enum';
    const name = capitalize(isEnum ? 'enum' : propName);
    const value = prop.type && prop.type.value;
    if (!name)
        return null;
    if (!Tooltip ||
        (isEnum && typeof value === 'string') ||
        (!prop.flowType && !isEnum && !value) ||
        (prop.flowType && !prop.flowType.elements)) {
        return name;
    }
    return prop.flowType ? (createElement(Tooltip, { text: humanize(prop.flowType) }, name)) : (createElement(Tooltip, { text: humanize(prop.type) }, name));
};
const BasePropsTable = ({ of: component, components }) => {
    const info = component.__docgenInfo;
    const props = info && info.props;
    if (!info || !props) {
        return null;
    }
    const hasDescription = Object.keys(props).some((name) => {
        const description = get(`${name}.description`, props);
        return Boolean(description) && Boolean(get('length', description));
    });
    const Table = components.table || 'table';
    const Thead = components.thead || 'thead';
    const Tr = components.tr || 'tr';
    const Th = components.th || 'th';
    const Tbody = components.tbody || 'tbody';
    const Td = components.td || 'td';
    const Tooltip = components.tooltip;
    return (createElement(Fragment, null,
        createElement(Table, { className: "PropsTable" },
            createElement(Thead, { style: styles$1.thead },
                createElement(Tr, null,
                    createElement(Th, { className: "PropsTable--property" }, "Property"),
                    createElement(Th, { className: "PropsTable--type" }, "Type"),
                    createElement(Th, { className: "PropsTable--required" }, "Required"),
                    createElement(Th, { className: "PropsTable--default" }, "Default"),
                    hasDescription && (createElement(Th, { width: "40%", className: "PropsTable--description" }, "Description")))),
            createElement(Tbody, null, props &&
                Object.keys(props).map((name) => {
                    const prop = props[name];
                    if (!prop.flowType && !prop.type)
                        return null;
                    return (createElement(Tr, { key: name },
                        createElement(Td, null, name),
                        createElement(Td, null, getPropType(prop, Tooltip)),
                        createElement(Td, null, String(prop.required)),
                        !prop.defaultValue ? (createElement(Td, null,
                            createElement("em", null, "-"))) : (createElement(Td, null, prop.defaultValue.value === "''" ? (createElement("em", null, "[Empty String]")) : (prop.defaultValue &&
                            prop.defaultValue.value.replace(/\'/g, '')))),
                        hasDescription && (createElement(Td, null, prop.description && prop.description))));
                })))));
};
const PropsTable = withMDXComponents(BasePropsTable);

const ThemeConfig = ({ children }) => {
    if (typeof children !== 'function')
        return null;
    return (createElement(Fragment, null, state.get(({ transform, config, themeConfig = {} }) => {
        const newConfig = merge(themeConfig, config ? config.themeConfig : {});
        return children(Object.assign({}, config, { themeConfig: transform ? transform(newConfig) : newConfig }));
    })));
};

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

class AsyncComponent extends Component {
    constructor() {
        super(...arguments);
        this.state = {
            loading: true,
            error: null,
            data: {},
        };
    }
    componentDidMount() {
        this.fetch();
    }
    render() {
        const _a = this.props, { as: Comp, getInitialData } = _a, props = __rest(_a, ["as", "getInitialData"]);
        const { data, loading, error } = this.state;
        return createElement(Comp, Object.assign({}, props, { data: Object.assign({}, data, { loading, error }) }));
    }
    async fetch() {
        const { getInitialData } = this.props;
        if (getInitialData && isFn(getInitialData)) {
            this.setState({ loading: true });
            try {
                const data = await getInitialData(this.props);
                this.setState({
                    data,
                    error: null,
                    loading: false,
                });
            }
            catch (error) {
                this.setState({
                    error,
                    data: {},
                    loading: false,
                });
            }
        }
    }
}

async function loadFromImports(path) {
    // tslint:disable-next-line
    const { imports } = await import('~imports');
    const { default: Component$$1, getInitialData } = await imports[path]();
    const ExportedComponent = props => (createElement(AsyncComponent, Object.assign({}, props, { as: Component$$1 || 'div', getInitialData: getInitialData })));
    return withMDXComponents(ExportedComponent);
}
const loadRoute = (path, LoadingComponent) => {
    const opts = { LoadingComponent };
    return importedComponent(async () => loadFromImports(path), opts);
};
const AsyncRoute = (_a) => {
    var { components, asyncComponent, path, entries } = _a, routeProps = __rest(_a, ["components", "asyncComponent", "path", "entries"]);
    const Page = components.page;
    const Component$$1 = asyncComponent;
    const entry = entries && entries[path];
    const props = Object.assign({}, routeProps, { doc: entry });
    return Page ? (createElement(Page, Object.assign({}, props),
        createElement(Component$$1, Object.assign({}, props)))) : (createElement(Component$$1, Object.assign({}, props)));
};

const DefaultLoading = () => createElement(Fragment, null, "Loading");
const Identity = ({ children }) => (createElement(Fragment, null, children));
const DefaultRender = ({ component, code }) => (createElement(Fragment, null,
    component,
    code));
const DefaultNotFound = () => createElement(Fragment, null, "Not found");
const defaultComponents = {
    loading: DefaultLoading,
    render: DefaultRender,
    notFound: DefaultNotFound,
    page: Identity,
};
const DocPreview = ({ components: themeComponents = {}, }) => {
    const components = Object.assign({}, defaultComponents, themeComponents);
    const NotFound = components.notFound;
    return (createElement(MDXProvider, { components: components }, state.get(({ entries }) => {
        if (!entries)
            return null;
        return (createElement(Switch, null,
            Object.keys(entries).map(path => {
                const entry = get(path, entries);
                const props = { path, entries, components };
                const component = loadRoute(path, components.loading);
                component.preload();
                return (createElement(Route, { exact: true, key: entry.id, path: entry.route, render: routeProps => (createElement(AsyncRoute, Object.assign({}, routeProps, props, { asyncComponent: component }))) }));
            }),
            NotFound && createElement(Route, { component: NotFound })));
    })));
};

export { theme, Docs, Link, Menu, Playground, PropsTable, ThemeConfig, DocPreview };
//# sourceMappingURL=index.m.js.map
