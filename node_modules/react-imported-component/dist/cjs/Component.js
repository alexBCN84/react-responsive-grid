"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.UnconnectedReactImportedComponent = exports.settings = void 0;

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _detectNode = _interopRequireDefault(require("detect-node"));

var _marks = require("./marks");

var _loadable = _interopRequireDefault(require("./loadable"));

var _context = require("./context");

var STATE_LOADING = 'loading';
var STATE_ERROR = 'error';
var STATE_DONE = 'done';

var FragmentNode = function FragmentNode(_ref) {
  var children = _ref.children;
  return _react.default.createElement("div", null, children);
};

FragmentNode.propTypes = process.env.NODE_ENV !== "production" ? {
  children: _propTypes.default.any
} : {};
var settings = {
  hot: !!module.hot,
  SSR: _detectNode.default
};
exports.settings = settings;

var getLoadable = function getLoadable(importFunction) {
  if ('promise' in importFunction) {
    return importFunction;
  }

  return (0, _loadable.default)(importFunction, false);
};

var UnconnectedReactImportedComponent =
/*#__PURE__*/
function (_Component) {
  (0, _inherits2.default)(UnconnectedReactImportedComponent, _Component);

  function UnconnectedReactImportedComponent(props) {
    var _this;

    (0, _classCallCheck2.default)(this, UnconnectedReactImportedComponent);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(UnconnectedReactImportedComponent).call(this, props));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "mounted", false);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)((0, _assertThisInitialized2.default)(_this)), "reload", function () {
      if (_this.mounted) {
        _this.setState({
          state: STATE_LOADING
        });
      }

      _this.remount();
    });
    _this.state = _this.pickPrecached() || {};
    var loadable = getLoadable(_this.props.loadable);
    loadable.load().catch(function () {
      return {};
    });
    _this.state.mark = loadable.mark;

    if (_detectNode.default && settings.SSR && typeof _this.props.streamId !== 'undefined') {
      (0, _marks.useMark)(_this.props.streamId, loadable.mark);

      if (_this.state.state !== STATE_DONE) {
        _this.state.state = STATE_LOADING;

        _this.reload();
      }
    }

    return _this;
  }

  (0, _createClass2.default)(UnconnectedReactImportedComponent, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.mounted = true;
      (0, _marks.useMark)(this.props.streamId, this.state.mark);

      if (this.state.state !== STATE_DONE) {
        this.reload();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.mounted = false;
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(oldProps) {
      // this.props.loadable would change only on HRM (or direct component usage)
      // just load it, do not use result
      if (oldProps.loadable !== this.props.loadable) {
        getLoadable(this.props.loadable).load().catch(function () {
          return {};
        });
      }
    }
  }, {
    key: "pickPrecached",
    value: function pickPrecached() {
      var loadable = getLoadable(this.props.loadable);

      if (loadable.done) {
        return {
          AsyncComponent: this.props.exportPicker(loadable.payload),
          state: loadable.ok ? STATE_DONE : STATE_ERROR,
          error: loadable.error
        };
      }

      return null;
    }
  }, {
    key: "loadAsyncComponent",
    value: function loadAsyncComponent() {
      var _this2 = this;

      var loadable = getLoadable(this.props.loadable);

      if (loadable.done) {
        this.setState(this.pickPrecached());
        return loadable.promise;
      } else {
        this.loadingPromise = loadable.load();
        return this.loadingPromise.then(function (payload) {
          if (_this2.mounted) {
            _this2.setState({
              AsyncComponent: _this2.props.exportPicker(payload),
              state: STATE_DONE
            });
          }
        });
      }
    }
  }, {
    key: "remount",
    value: function remount() {
      var _this3 = this;

      this.loadAsyncComponent().catch(function (err) {
        if (_this3.mounted) {
          /* eslint-disable */
          console.error('[React-imported-component]', err);
          /* eslint-enable */

          _this3.setState({
            state: STATE_ERROR,
            error: err
          });

          if (_this3.props.onError) {
            _this3.props.onError(err);
          } else {
            throw err;
          }
        }
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state = this.state,
          AsyncComponent = _this$state.AsyncComponent,
          state = _this$state.state;
      var _this$props = this.props,
          LoadingComponent = _this$props.LoadingComponent,
          ErrorComponent = _this$props.ErrorComponent;

      if (state === STATE_LOADING && this.props.async) {
        throw this.loadingPromise;
      }

      if (this.props.render) {
        return this.props.render(AsyncComponent, state, this.props.forwardProps);
      }

      if (AsyncComponent) {
        return _react.default.createElement(AsyncComponent, (0, _extends2.default)({}, this.props.forwardProps, {
          ref: this.props.forwardRef
        }));
      }

      switch (state) {
        case STATE_LOADING:
          return LoadingComponent ? _react.default.Children.only(_react.default.createElement(LoadingComponent, this.props.forwardProps)) : null;

        case STATE_ERROR:
          if (ErrorComponent) {
            return _react.default.Children.only(_react.default.createElement(ErrorComponent, (0, _extends2.default)({
              retryImport: this.reload,
              error: this.state.error
            }, this.props.forwardProps)));
          }

          throw this.state.error;

        default:
          return null;
      }
    }
  }]);
  return UnconnectedReactImportedComponent;
}(_react.Component);

exports.UnconnectedReactImportedComponent = UnconnectedReactImportedComponent;

var es6import = function es6import(module) {
  return module.default ? module.default : module;
};

var BaseProps = process.env.NODE_ENV !== "production" ? {
  loadable: _propTypes.default.oneOfType([_propTypes.default.object, _propTypes.default.func]).isRequired,
  LoadingComponent: _propTypes.default.func,
  ErrorComponent: _propTypes.default.func,
  exportPicker: _propTypes.default.func,
  render: _propTypes.default.func,
  ssrMark: _propTypes.default.string,
  async: _propTypes.default.bool,
  onError: _propTypes.default.func,
  forwardProps: _propTypes.default.object,
  forwardRef: _propTypes.default.func
} : {};
UnconnectedReactImportedComponent.propTypes = process.env.NODE_ENV !== "production" ? (0, _objectSpread2.default)({}, BaseProps, {
  streamId: _propTypes.default.number
}) : {};
UnconnectedReactImportedComponent.defaultProps = {
  exportPicker: es6import,
  async: false
};

var ReactImportedComponent = function ReactImportedComponent(props) {
  return settings.SSR ? _react.default.createElement(_context.UIDConsumer, null, function (UID) {
    return _react.default.createElement(UnconnectedReactImportedComponent, (0, _extends2.default)({}, props, {
      streamId: UID | 0
    }));
  }) : _react.default.createElement(UnconnectedReactImportedComponent, (0, _extends2.default)({}, props, {
    streamId: 0
  }));
};

ReactImportedComponent.propTypes = process.env.NODE_ENV !== "production" ? BaseProps : {};
var _default = ReactImportedComponent;
exports.default = _default;