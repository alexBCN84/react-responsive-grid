"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.assignImportedComponents = exports.dryRender = exports.done = exports.importMatch = void 0;

var _detectNode = _interopRequireDefault(require("detect-node"));

var _marks = require("./marks");

var pending = [];

var addPending = function addPending(promise) {
  return pending.push(promise);
};

var removeFromPending = function removeFromPending(promise) {
  return pending = pending.filter(function (a) {
    return a !== promise;
  });
};

var trimImport = function trimImport(str) {
  return str.replace(/['"]/g, '');
};

var importMatch = function importMatch(functionString) {
  var markMatches = functionString.match(/['"]imported_(.*?)_component['"]/g) || [];
  return markMatches.map(function (match) {
    return trimImport(match.match(/['"]imported_(.*?)_component['"]/i)[1]);
  });
};

exports.importMatch = importMatch;

var toLoadable = function toLoadable(importFunction) {
  var autoImport = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  var _load = function _load() {
    return Promise.resolve().then(importFunction);
  };

  var mark = importMatch(importFunction.toString());
  var resolveResolution;
  var resolution = new Promise(function (r) {
    resolveResolution = r;
  });
  var loadable = {
    importFunction: importFunction,
    mark: mark,
    resolution: resolution,
    done: false,
    ok: false,
    error: null,
    payload: undefined,
    promise: undefined,
    reset: function reset() {
      this.done = false;
      this.ok = true;
      this.payload = undefined;
      this.promise = undefined;
    },
    load: function load() {
      var _this = this;

      if (!this.promise) {
        var promise = this.promise = _load().then(function (payload) {
          _this.done = true;
          _this.ok = true;
          _this.payload = payload;
          _this.error = null;
          removeFromPending(promise);
          resolveResolution(payload);
          return payload;
        }, function (err) {
          _this.done = true;
          _this.ok = false;
          _this.error = err;
          removeFromPending(promise);
          throw err;
        });

        addPending(promise);
      }

      return this.promise;
    }
  };

  if (mark) {
    mark.forEach(function (subMark) {
      return (0, _marks.loadMark)(subMark, loadable);
    });
  }

  if (_detectNode.default && autoImport) {
    loadable.load();
  }

  return loadable;
};

var done = function done() {
  if (pending.length) {
    return Promise.all(pending).then(function (a) {
      return a[1];
    }).then(done);
  } else {
    return Promise.resolve();
  }
};

exports.done = done;

var dryRender = function dryRender(renderFunction) {
  renderFunction();
  return Promise.resolve().then(done);
};

exports.dryRender = dryRender;

var assignImportedComponents = function assignImportedComponents(set) {
  Object.keys(set).forEach(function (key) {
    return toLoadable(set[key]);
  });
};

exports.assignImportedComponents = assignImportedComponents;
var _default = toLoadable;
exports.default = _default;