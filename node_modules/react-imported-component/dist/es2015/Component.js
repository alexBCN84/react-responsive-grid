import _extends from "@babel/runtime/helpers/extends";
import _inheritsLoose from "@babel/runtime/helpers/inheritsLoose";
import _assertThisInitialized from "@babel/runtime/helpers/assertThisInitialized";
import _defineProperty from "@babel/runtime/helpers/defineProperty";
import React, { Component } from 'react';
import PropTypes from 'prop-types';
import isNode from 'detect-node';
import { useMark } from './marks';
import toLoadable from "./loadable";
import { UIDConsumer } from "./context";
var STATE_LOADING = 'loading';
var STATE_ERROR = 'error';
var STATE_DONE = 'done';

var FragmentNode = function FragmentNode(_ref) {
  var children = _ref.children;
  return React.createElement("div", null, children);
};

FragmentNode.propTypes = process.env.NODE_ENV !== "production" ? {
  children: PropTypes.any
} : {};
export var settings = {
  hot: !!module.hot,
  SSR: isNode
};

var getLoadable = function getLoadable(importFunction) {
  if ('promise' in importFunction) {
    return importFunction;
  }

  return toLoadable(importFunction, false);
};

export var UnconnectedReactImportedComponent =
/*#__PURE__*/
function (_Component) {
  _inheritsLoose(UnconnectedReactImportedComponent, _Component);

  function UnconnectedReactImportedComponent(props) {
    var _this;

    _this = _Component.call(this, props) || this;

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "mounted", false);

    _defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), "reload", function () {
      if (_this.mounted) {
        _this.setState({
          state: STATE_LOADING
        });
      }

      _this.remount();
    });

    _this.state = _this.pickPrecached() || {};
    var loadable = getLoadable(_this.props.loadable);
    loadable.load().catch(function () {
      return {};
    });
    _this.state.mark = loadable.mark;

    if (isNode && settings.SSR && typeof _this.props.streamId !== 'undefined') {
      useMark(_this.props.streamId, loadable.mark);

      if (_this.state.state !== STATE_DONE) {
        _this.state.state = STATE_LOADING;

        _this.reload();
      }
    }

    return _this;
  }

  var _proto = UnconnectedReactImportedComponent.prototype;

  _proto.componentDidMount = function componentDidMount() {
    this.mounted = true;
    useMark(this.props.streamId, this.state.mark);

    if (this.state.state !== STATE_DONE) {
      this.reload();
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this.mounted = false;
  };

  _proto.componentDidUpdate = function componentDidUpdate(oldProps) {
    // this.props.loadable would change only on HRM (or direct component usage)
    // just load it, do not use result
    if (oldProps.loadable !== this.props.loadable) {
      getLoadable(this.props.loadable).load().catch(function () {
        return {};
      });
    }
  };

  _proto.pickPrecached = function pickPrecached() {
    var loadable = getLoadable(this.props.loadable);

    if (loadable.done) {
      return {
        AsyncComponent: this.props.exportPicker(loadable.payload),
        state: loadable.ok ? STATE_DONE : STATE_ERROR,
        error: loadable.error
      };
    }

    return null;
  };

  _proto.loadAsyncComponent = function loadAsyncComponent() {
    var _this2 = this;

    var loadable = getLoadable(this.props.loadable);

    if (loadable.done) {
      this.setState(this.pickPrecached());
      return loadable.promise;
    } else {
      this.loadingPromise = loadable.load();
      return this.loadingPromise.then(function (payload) {
        if (_this2.mounted) {
          _this2.setState({
            AsyncComponent: _this2.props.exportPicker(payload),
            state: STATE_DONE
          });
        }
      });
    }
  };

  _proto.remount = function remount() {
    var _this3 = this;

    this.loadAsyncComponent().catch(function (err) {
      if (_this3.mounted) {
        /* eslint-disable */
        console.error('[React-imported-component]', err);
        /* eslint-enable */

        _this3.setState({
          state: STATE_ERROR,
          error: err
        });

        if (_this3.props.onError) {
          _this3.props.onError(err);
        } else {
          throw err;
        }
      }
    });
  };

  _proto.render = function render() {
    var _this$state = this.state,
        AsyncComponent = _this$state.AsyncComponent,
        state = _this$state.state;
    var _this$props = this.props,
        LoadingComponent = _this$props.LoadingComponent,
        ErrorComponent = _this$props.ErrorComponent;

    if (state === STATE_LOADING && this.props.async) {
      throw this.loadingPromise;
    }

    if (this.props.render) {
      return this.props.render(AsyncComponent, state, this.props.forwardProps);
    }

    if (AsyncComponent) {
      return React.createElement(AsyncComponent, _extends({}, this.props.forwardProps, {
        ref: this.props.forwardRef
      }));
    }

    switch (state) {
      case STATE_LOADING:
        return LoadingComponent ? React.Children.only(React.createElement(LoadingComponent, this.props.forwardProps)) : null;

      case STATE_ERROR:
        if (ErrorComponent) {
          return React.Children.only(React.createElement(ErrorComponent, _extends({
            retryImport: this.reload,
            error: this.state.error
          }, this.props.forwardProps)));
        }

        throw this.state.error;

      default:
        return null;
    }
  };

  return UnconnectedReactImportedComponent;
}(Component);

var es6import = function es6import(module) {
  return module.default ? module.default : module;
};

var BaseProps = process.env.NODE_ENV !== "production" ? {
  loadable: PropTypes.oneOfType([PropTypes.object, PropTypes.func]).isRequired,
  LoadingComponent: PropTypes.func,
  ErrorComponent: PropTypes.func,
  exportPicker: PropTypes.func,
  render: PropTypes.func,
  ssrMark: PropTypes.string,
  async: PropTypes.bool,
  onError: PropTypes.func,
  forwardProps: PropTypes.object,
  forwardRef: PropTypes.func
} : {};
UnconnectedReactImportedComponent.propTypes = process.env.NODE_ENV !== "production" ? _extends({}, BaseProps, {
  streamId: PropTypes.number
}) : {};
UnconnectedReactImportedComponent.defaultProps = {
  exportPicker: es6import,
  async: false
};

var ReactImportedComponent = function ReactImportedComponent(props) {
  return settings.SSR ? React.createElement(UIDConsumer, null, function (UID) {
    return React.createElement(UnconnectedReactImportedComponent, _extends({}, props, {
      streamId: UID | 0
    }));
  }) : React.createElement(UnconnectedReactImportedComponent, _extends({}, props, {
    streamId: 0
  }));
};

ReactImportedComponent.propTypes = process.env.NODE_ENV !== "production" ? BaseProps : {};
export default ReactImportedComponent;