import isNode from 'detect-node';
import { loadMark } from './marks';
var pending = [];

var addPending = function addPending(promise) {
  return pending.push(promise);
};

var removeFromPending = function removeFromPending(promise) {
  return pending = pending.filter(function (a) {
    return a !== promise;
  });
};

var trimImport = function trimImport(str) {
  return str.replace(/['"]/g, '');
};

export var importMatch = function importMatch(functionString) {
  var markMatches = functionString.match(/['"]imported_(.*?)_component['"]/g) || [];
  return markMatches.map(function (match) {
    return trimImport(match.match(/['"]imported_(.*?)_component['"]/i)[1]);
  });
};

var toLoadable = function toLoadable(importFunction, autoImport) {
  if (autoImport === void 0) {
    autoImport = true;
  }

  var _load = function _load() {
    return Promise.resolve().then(importFunction);
  };

  var mark = importMatch(importFunction.toString());
  var resolveResolution;
  var resolution = new Promise(function (r) {
    resolveResolution = r;
  });
  var loadable = {
    importFunction: importFunction,
    mark: mark,
    resolution: resolution,
    done: false,
    ok: false,
    error: null,
    payload: undefined,
    promise: undefined,
    reset: function reset() {
      this.done = false;
      this.ok = true;
      this.payload = undefined;
      this.promise = undefined;
    },
    load: function load() {
      var _this = this;

      if (!this.promise) {
        var promise = this.promise = _load().then(function (payload) {
          _this.done = true;
          _this.ok = true;
          _this.payload = payload;
          _this.error = null;
          removeFromPending(promise);
          resolveResolution(payload);
          return payload;
        }, function (err) {
          _this.done = true;
          _this.ok = false;
          _this.error = err;
          removeFromPending(promise);
          throw err;
        });

        addPending(promise);
      }

      return this.promise;
    }
  };

  if (mark) {
    mark.forEach(function (subMark) {
      return loadMark(subMark, loadable);
    });
  }

  if (isNode && autoImport) {
    loadable.load();
  }

  return loadable;
};

export var done = function done() {
  if (pending.length) {
    return Promise.all(pending).then(function (a) {
      return a[1];
    }).then(done);
  } else {
    return Promise.resolve();
  }
};
export var dryRender = function dryRender(renderFunction) {
  renderFunction();
  return Promise.resolve().then(done);
};
export var assignImportedComponents = function assignImportedComponents(set) {
  Object.keys(set).forEach(function (key) {
    return toLoadable(set[key]);
  });
};
export default toLoadable;